/**
 * Move.lock V4 Generator
 *
 * Generates Move.lock files in the V4 format for the new package management system.
 *
 * ORIGINAL SOURCE REFERENCES:
 * - move-package-alt/src/graph/to_lockfile.rs - PackageGraph::to_pins() generates lockfile pins
 * - move-package-alt/src/schema/lockfile.rs - Pin struct definition (source, manifest_digest, deps)
 * - move-package-alt/src/package/root_package.rs:279-283 - save_lockfile_to_disk() writes lockfile
 *
 * NOTE: manifest_digest is left empty because exact CLI-compatible digest computation
 * requires Rust struct serialization. This can be addressed when WASM exposes
 * lockfile generation functionality.
 */

import { DependencyGraph, DependencySource } from "./dependencyGraph.js";

/** Move.lock V4 schema version */
export const LOCKFILE_VERSION = 4;

/** Pinned package info in Move.lock V4 */
export interface PinnedPackage {
  source: PinnedSource;
  "manifest-digest"?: string;
  deps: Record<string, string>;
}

/** Source types for pinned packages */
export type PinnedSource =
  | { root: true }
  | { local: string }
  | { git: string; subdir: string; rev: string };

/** Move.lock V4 structure */
export interface MoveLockV4 {
  move: { version: number };
  pinned: Record<string, Record<string, PinnedPackage>>;
}

/**
 * Convert a DependencySource to PinnedSource format
 */
function toPinnedSource(
  source: DependencySource,
  isRoot: boolean
): PinnedSource {
  if (isRoot) {
    return { root: true };
  }

  if (source.local) {
    return { local: source.local };
  }

  if (source.git && source.rev) {
    return {
      git: source.git,
      subdir: source.subdir || "",
      rev: source.rev,
    };
  }

  // Fallback to root for unknown sources
  return { root: true };
}

/**
 * Escape a TOML string value
 */
function escapeTomlString(str: string): string {
  return str
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"')
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r")
    .replace(/\t/g, "\\t");
}

/**
 * Generate Move.lock V4 content from a DependencyGraph
 */
export function generateMoveLockV4(
  graph: DependencyGraph,
  environment: string
): string {
  const lines: string[] = [];

  // Header
  lines.push("# Generated by move; do not edit");
  lines.push("# This file should be checked in.");
  lines.push("");
  lines.push("[move]");
  lines.push(`version = ${LOCKFILE_VERSION}`);
  lines.push("");

  // Get all packages in topological order
  const rootName = graph.getRootName();
  const allPackages = [rootName, ...graph.topologicalOrder()];

  // Generate pinned sections for each package
  for (const pkgName of allPackages) {
    const pkg = graph.getPackage(pkgName);
    if (!pkg) continue;

    const isRoot = pkgName === rootName;
    const sectionKey = `pinned.${environment}.${pkgName}`;

    lines.push(`[${sectionKey}]`);

    // Source
    const source = toPinnedSource(pkg.id.source, isRoot);
    if ("root" in source) {
      lines.push("source = { root = true }");
    } else if ("local" in source) {
      lines.push(`source = { local = "${escapeTomlString(source.local)}" }`);
    } else {
      lines.push(
        `source = { git = "${escapeTomlString(source.git)}", subdir = "${escapeTomlString(source.subdir)}", rev = "${escapeTomlString(source.rev)}" }`
      );
    }

    // Manifest digest (placeholder - would need actual computation)
    // lines.push(`manifest-digest = "..."`);

    // Dependencies
    const deps = graph.getImmediateDependencies(pkgName);
    if (deps.size > 0) {
      const depParts: string[] = [];
      for (const depName of Array.from(deps).sort()) {
        depParts.push(`${depName} = "${depName}"`);
      }
      lines.push(`deps = { ${depParts.join(", ")} }`);
    } else {
      lines.push("deps = {}");
    }

    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate Move.lock V4 from resolved dependencies JSON
 * This is an alternative entry point when working with serialized data
 * @param digestFn Optional function to compute manifest digest (from WASM)
 */
/**
 * Generate Move.lock V4 from resolved dependencies JSON
 * This is an alternative entry point when working with serialized data
 * @param digestFn Optional function to compute manifest digest (from WASM)
 */
export function generateMoveLockV4FromJson(
  depsJson: string,
  rootPackageName: string,
  environment: string,
  rootManifestDeps?: string[],
  digestFn?: (depsJson: string) => string,
  rootManifestDepsInfo?: Record<string, any>,
  rootDepAliasToPackageName?: Record<string, string>,
  existingLockfile?: string // ORIGINAL: root_package.rs:269-283 - CLI reads existing lockfile and preserves other environments
): string {
  const lines: string[] = [];

  // Header
  lines.push("# Generated by move; do not edit");
  lines.push("# This file should be checked in.");
  lines.push("");
  lines.push("[move]");
  lines.push(`version = ${LOCKFILE_VERSION}`);
  lines.push("");

  try {
    const deps = JSON.parse(depsJson) as Array<{
      name: string;
      files: Record<string, string>;
      manifest?: {
        name?: string;
        dependencies?: Record<string, unknown>;
      };
      source?: {
        type: string;
        git?: string;
        rev?: string;
        subdir?: string;
        local?: string;
      };
      manifestDeps?: string[];
      /** Maps Move.toml deps key (alias) â†’ resolved package name */
      depAliasToPackageName?: Record<string, string>;
    }>;

    // Build a map of package name to full dep info for digest computation
    const depsByName = new Map(deps.map((d) => [d.name, d]));

    // Helper to build digest input JSON using ORIGINAL Move.toml dependency info
    // CLI uses original manifest deps - preserves both git and local dep types
    const buildDigestInputFromManifest = (
      manifestDeps: Record<string, any> | undefined,
      depNames: string[],
      packageName: string
    ): string => {
      const depsInfo = depNames.map((name) => {
        const depInfo = manifestDeps?.[name];
        if (depInfo?.git) {
          // Git dependency: { git = "...", subdir = "...", rev = "..." }
          return {
            name,
            git: depInfo.git,
            subdir: depInfo.subdir || "",
            rev: depInfo.rev || "",
            use_environment: environment,
          };
        } else if (depInfo?.local) {
          // Local dependency: { local = "..." }
          return {
            name,
            local: depInfo.local,
            use_environment: environment,
          };
        }
        // ORIGINAL: package_impl.rs:287-308 - compute_digest() serializes CombinedDependency to TOML
        // ORIGINAL: manifest.rs:155-170 - override_system_dep() returns { system: name, is_override: true }
        // For implicit deps (std, sui) not in manifestDeps, return system dep format for digest compatibility
        // If dep is not in manifestDeps, check if it's an implicit dep and add system info
        const lowerName = name.toLowerCase();
        if (
          lowerName === "sui" ||
          lowerName === "std" ||
          lowerName === "movestdlib"
        ) {
          // Implicit/system dependency - add system dep format for digest compatibility
          return {
            name,
            system: lowerName === "movestdlib" ? "std" : lowerName,
            is_override: true,
            use_environment: environment,
          };
        }
        // For other deps (on-chain, etc.), just include name
        return { name, use_environment: environment };
      });

      // [FIX] Strict adherence to `move-package` Rust logic.
      // If ANY implicit dependency is explicitly present, DO NOT add defaults.
      //
      // ORIGINAL SOURCE REFERENCE:
      // - sui-package-alt/src/sui_flavor.rs:96-108 - SuiFlavor::implicit_dependencies()
      //   Returns { "sui" -> override_system_dep("sui"), "std" -> override_system_dep("std") }
      // - sui-package-alt/src/sui_flavor.rs:55-60 - default_system_dep_names()
      //   Returns BTreeSet::from([PackageName::new("sui"), PackageName::new("std")])
      // - sui-package-alt/src/sui_flavor.rs:44-51 - system_deps_names_map()
      //   Maps legacy names: Sui->sui, SuiSystem->sui_system, MoveStdlib->std, Bridge->bridge, DeepBook->deepbook
      //
      const explicitDepNames = depNames; // alias
      const implicitsFound = explicitDepNames.some((n) => {
        const lower = n.toLowerCase();
        // Check against known implicit dep names from sui_flavor.rs
        return lower === "sui" || lower === "std" || lower === "movestdlib";
      });
      const lowerPkgName = packageName.toLowerCase();
      const implicitDeps: any[] = [];

      // Add implicit deps only if:
      // 1. No implicit deps are explicitly listed in manifest
      // 2. Package itself is not an implicit/system package
      // ORIGINAL: sui_flavor.rs:96-108 - System packages don't get implicit deps
      // Use startsWith to handle suffixed names (MoveStdlib_1, Sui_2, etc.)
      const isSystemPackage =
        lowerPkgName === "sui" ||
        lowerPkgName.startsWith("sui_") ||
        lowerPkgName === "std" ||
        lowerPkgName === "movestdlib" ||
        lowerPkgName.startsWith("movestdlib_");
      if (!implicitsFound && !isSystemPackage) {
        implicitDeps.push({
          name: "sui",
          system: "sui",
          is_override: true,
          use_environment: environment,
        });
        implicitDeps.push({
          name: "std",
          system: "std",
          is_override: true,
          use_environment: environment,
        });
      }

      const combined = [...depsInfo, ...implicitDeps];

      return JSON.stringify({ deps: combined });
    };

    // Collect all packages (root + deps) to sort them by name
    // CLI behavior: [pinned] table keys are sorted lexicographically
    const allPackages: Array<{
      name: string;
      isRoot: boolean;
      dep?: (typeof deps)[0];
    }> = [];

    // Add Root Package
    allPackages.push({ name: rootPackageName, isRoot: true });

    // Add Dependencies
    for (const dep of deps) {
      allPackages.push({ name: dep.name, isRoot: false, dep });
    }

    // Sort by package name (ASCII)
    allPackages.sort((a, b) =>
      a.name < b.name ? -1 : a.name > b.name ? 1 : 0
    );

    // Generate sections in sorted order
    for (const pkg of allPackages) {
      const sectionKey = `pinned.${environment}.${pkg.name}`;
      lines.push(`[${sectionKey}]`);

      // Helper to determine implicit deps for this package
      const _depsInfo = pkg.isRoot
        ? rootManifestDepsInfo
          ? Object.keys(rootManifestDepsInfo).map(
              (k) => rootManifestDepsInfo[k]
            )
          : []
        : [];

      // Reconstruct depsInfo for non-root packages from manifest
      // This is duplicative but necessary since we don't have the normalized object easily handy above without refactoring
      // Actually, we can just use the logic from buildDigestInputFromManifest if we extract it.
      // Let's inline the logic cleanly.

      // 1. Get Explicit Deps Names
      // ORIGINAL: dependency_graph.rs:1284-1289 - CLI writes deps from package_graph.edges()
      // For lockfile-loaded packages, use depAliasToPackageName (from lockfile deps)
      // For manifest-fallback packages, use manifestDeps (from Move.toml)
      const explicitDepNames = pkg.isRoot
        ? rootManifestDeps || []
        : pkg.dep!.depAliasToPackageName
          ? Object.keys(pkg.dep!.depAliasToPackageName)
          : pkg.dep!.manifestDeps ||
            Object.keys(pkg.dep!.manifest?.dependencies || {});

      // 2. Identify Implicits (Strict adherence to move-package logic)
      const implicitsFound = explicitDepNames.some((n) => {
        const lower = n.toLowerCase();
        return lower === "sui" || lower === "std" || lower === "movestdlib";
      });

      const lowerPkgName = pkg.name.toLowerCase();

      const implicitDepsForOutput: string[] = [];
      // If no implicit deps are explicitly present, and we are not a system package, add defaults.
      // Use startsWith to handle suffixed names (e.g., MoveStdlib_1, Sui_1)
      // ORIGINAL: CLI doesn't add implicit deps to system packages
      const isSystemPackage =
        lowerPkgName === "sui" ||
        lowerPkgName.startsWith("sui_") ||
        lowerPkgName === "std" ||
        lowerPkgName === "movestdlib" ||
        lowerPkgName.startsWith("movestdlib_");
      if (!implicitsFound && !isSystemPackage) {
        implicitDepsForOutput.push("sui");
        implicitDepsForOutput.push("std");
      }

      if (pkg.isRoot) {
        // Root Package Logic
        lines.push("source = { root = true }");
        lines.push(`use_environment = "${environment}"`);

        const rootDigest = digestFn
          ? digestFn(
              buildDigestInputFromManifest(
                rootManifestDepsInfo,
                explicitDepNames,
                rootPackageName
              )
            )
          : "";
        lines.push(`manifest_digest = "${rootDigest}"`);

        const finalDeps = [
          ...explicitDepNames,
          ...implicitDepsForOutput,
        ].sort();

        if (finalDeps.length > 0) {
          const rootAliasMap = rootDepAliasToPackageName || {};
          const depParts = finalDeps.map((alias) => {
            // Resolve alias to package name
            // For explicit deps, use map.
            // For implicit deps, map "sui"->"Sui", "std"->"MoveStdlib".
            let pkgName = rootAliasMap[alias] || alias;
            if (alias === "sui" && !rootAliasMap[alias]) {
              // Try to find if 'Sui' package exists in the graph to confirm casing?
              // Default to 'Sui' if map missing? Or 'sui'?
              // Ref lockfile uses 'Sui'.
              if (depsByName.has("Sui")) pkgName = "Sui";
            }
            if (alias === "std" && !rootAliasMap[alias]) {
              if (depsByName.has("MoveStdlib")) pkgName = "MoveStdlib";
            }
            return `${alias} = "${pkgName}"`;
          });
          lines.push(`deps = { ${depParts.join(", ")} }`);
        } else {
          lines.push("deps = {}");
        }
      } else {
        // Dependency Logic
        const dep = pkg.dep!;
        const source = dep.source;
        if (source?.type === "git" && source?.git && source?.rev) {
          lines.push(
            `source = { git = "${escapeTomlString(source?.git)}", subdir = "${escapeTomlString(source?.subdir || "")}", rev = "${escapeTomlString(source?.rev)}" }`
          );
        } else if (source?.type === "local" && source?.local) {
          lines.push(
            `source = { local = "${escapeTomlString(source?.local)}" }`
          );
        } else {
          lines.push("source = { root = true }");
        }

        lines.push(`use_environment = "${environment}"`);

        // Digest Calculation (uses built-in logic I added previously)
        const depDigest = digestFn
          ? digestFn(
              buildDigestInputFromManifest(
                dep.manifest?.dependencies as Record<string, any>,
                explicitDepNames,
                pkg.name
              )
            )
          : "";
        lines.push(`manifest_digest = "${depDigest}"`);

        // Deps Generation
        const finalDeps = [
          ...explicitDepNames,
          ...implicitDepsForOutput,
        ].sort();

        if (finalDeps.length > 0) {
          const aliasMap = dep.depAliasToPackageName || {};
          const depParts = finalDeps.map((alias) => {
            let pkgName = aliasMap[alias] || alias;
            if (alias === "sui" && !aliasMap[alias]) {
              if (depsByName.has("Sui")) pkgName = "Sui";
            }
            if (alias === "std" && !aliasMap[alias]) {
              if (depsByName.has("MoveStdlib")) pkgName = "MoveStdlib";
            }
            return `${alias} = "${pkgName}"`;
          });
          lines.push(`deps = { ${depParts.join(", ")} }`);
        } else {
          lines.push("deps = {}");
        }
      }
      lines.push("");
    }
  } catch (e: any) {
    console.error("Lockfile generation error:", e);
    // If parsing fails, return minimal valid lockfile
    lines.push(`[pinned.${environment}.${rootPackageName}]`);
    lines.push("source = { root = true }");
    lines.push(`use_environment = "${environment}"`);
    lines.push(`manifest_digest = ""`);
    lines.push("deps = {}");
    lines.push("");
  }

  // ORIGINAL: root_package.rs:272-282 - CLI reads existing lockfile and preserves other environments
  // lockfile.pinned.insert(current_env, pins) only updates current environment
  // Other environments in existing lockfile are preserved
  if (existingLockfile) {
    try {
      // Parse existing lockfile to find sections from other environments
      const existingLines = existingLockfile.split("\n");
      let currentSection: string[] = [];
      let currentEnvName = "";
      let inOtherEnv = false;

      for (const line of existingLines) {
        const sectionMatch = line.match(/^\[pinned\.([^.]+)\./);
        if (sectionMatch) {
          // If we were collecting a section from another env, add it
          if (inOtherEnv && currentSection.length > 0) {
            lines.push(...currentSection);
            lines.push("");
          }

          currentEnvName = sectionMatch[1];
          inOtherEnv = currentEnvName !== environment;
          currentSection = inOtherEnv ? [line] : [];
        } else if (inOtherEnv) {
          // Continue collecting lines for other environment section
          if (line.trim() !== "" || currentSection.length > 0) {
            currentSection.push(line);
          }
        }
      }

      // Don't forget the last section
      if (inOtherEnv && currentSection.length > 0) {
        lines.push(...currentSection);
        lines.push("");
      }
    } catch {
      // If parsing fails, continue with just current environment
    }
  }

  return lines.join("\n");
}
