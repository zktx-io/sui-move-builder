/**
 * Move.lock V4 Generator
 *
 * Generates Move.lock files in the V4 format for the new package management system.
 * 
 * NOTE: manifest_digest is left empty because exact CLI-compatible digest computation
 * requires Rust struct serialization. This can be addressed when WASM exposes 
 * lockfile generation functionality.
 */

import { DependencyGraph, Package, DependencySource } from "./dependencyGraph.js";

/** Move.lock V4 schema version */
export const LOCKFILE_VERSION = 4;

/** Pinned package info in Move.lock V4 */
export interface PinnedPackage {
    source: PinnedSource;
    "manifest-digest"?: string;
    deps: Record<string, string>;
}

/** Source types for pinned packages */
export type PinnedSource =
    | { root: true }
    | { local: string }
    | { git: string; subdir: string; rev: string };

/** Move.lock V4 structure */
export interface MoveLockV4 {
    move: { version: number };
    pinned: Record<string, Record<string, PinnedPackage>>;
}

/**
 * Convert a DependencySource to PinnedSource format
 */
function toPinnedSource(source: DependencySource, isRoot: boolean): PinnedSource {
    if (isRoot) {
        return { root: true };
    }

    if (source.local) {
        return { local: source.local };
    }

    if (source.git && source.rev) {
        return {
            git: source.git,
            subdir: source.subdir || "",
            rev: source.rev,
        };
    }

    // Fallback to root for unknown sources
    return { root: true };
}

/**
 * Escape a TOML string value
 */
function escapeTomlString(str: string): string {
    return str
        .replace(/\\/g, "\\\\")
        .replace(/"/g, '\\"')
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/\t/g, "\\t");
}

/**
 * Generate Move.lock V4 content from a DependencyGraph
 */
export function generateMoveLockV4(
    graph: DependencyGraph,
    environment: string
): string {
    const lines: string[] = [];

    // Header
    lines.push("# Generated by move; do not edit");
    lines.push("# This file should be checked in.");
    lines.push("");
    lines.push("[move]");
    lines.push(`version = ${LOCKFILE_VERSION}`);
    lines.push("");

    // Get all packages in topological order
    const rootName = graph.getRootName();
    const allPackages = [rootName, ...graph.topologicalOrder()];

    // Generate pinned sections for each package
    for (const pkgName of allPackages) {
        const pkg = graph.getPackage(pkgName);
        if (!pkg) continue;

        const isRoot = pkgName === rootName;
        const sectionKey = `pinned.${environment}.${pkgName}`;

        lines.push(`[${sectionKey}]`);

        // Source
        const source = toPinnedSource(pkg.id.source, isRoot);
        if ("root" in source) {
            lines.push("source = { root = true }");
        } else if ("local" in source) {
            lines.push(`source = { local = "${escapeTomlString(source.local)}" }`);
        } else {
            lines.push(
                `source = { git = "${escapeTomlString(source.git)}", subdir = "${escapeTomlString(source.subdir)}", rev = "${escapeTomlString(source.rev)}" }`
            );
        }

        // Manifest digest (placeholder - would need actual computation)
        // lines.push(`manifest-digest = "..."`);

        // Dependencies
        const deps = graph.getImmediateDependencies(pkgName);
        if (deps.size > 0) {
            const depParts: string[] = [];
            for (const depName of Array.from(deps).sort()) {
                depParts.push(`${depName} = "${depName}"`);
            }
            lines.push(`deps = { ${depParts.join(", ")} }`);
        } else {
            lines.push("deps = {}");
        }

        lines.push("");
    }

    return lines.join("\n");
}

/**
 * Generate Move.lock V4 from resolved dependencies JSON
 * This is an alternative entry point when working with serialized data
 * @param digestFn Optional function to compute manifest digest (from WASM)
 */
export function generateMoveLockV4FromJson(
    depsJson: string,
    rootPackageName: string,
    environment: string,
    rootManifestDeps?: string[],
    digestFn?: (depsJson: string) => string,
    rootManifestDepsInfo?: Record<string, any>
): string {
    const lines: string[] = [];

    // Header
    lines.push("# Generated by move; do not edit");
    lines.push("# This file should be checked in.");
    lines.push("");
    lines.push("[move]");
    lines.push(`version = ${LOCKFILE_VERSION}`);
    lines.push("");

    try {
        const deps = JSON.parse(depsJson) as Array<{
            name: string;
            files: Record<string, string>;
            manifest?: {
                name?: string;
                dependencies?: Record<string, unknown>;
            };
            source?: {
                type: string;
                git?: string;
                rev?: string;
                subdir?: string;
                local?: string;
            };
            manifestDeps?: string[];
        }>;

        // Build a map of package name to full dep info for digest computation
        const depsByName = new Map(deps.map(d => [d.name, d]));

        // Helper to build digest input JSON using ORIGINAL Move.toml dependency info
        // CLI uses original manifest deps - preserves both git and local dep types
        const buildDigestInputFromManifest = (
            manifestDeps: Record<string, any> | undefined,
            depNames: string[]
        ): string => {
            const depsInfo = depNames.map(name => {
                const depInfo = manifestDeps?.[name];
                if (depInfo?.git) {
                    // Git dependency: { git = "...", subdir = "...", rev = "..." }
                    return {
                        name,
                        git: depInfo.git,
                        subdir: depInfo.subdir || "",
                        rev: depInfo.rev || "",
                        use_environment: environment
                    };
                } else if (depInfo?.local) {
                    // Local dependency: { local = "..." }
                    return {
                        name,
                        local: depInfo.local,
                        use_environment: environment
                    };
                }
                // For other deps (system, on-chain, etc.), just include name
                return { name, use_environment: environment };
            });
            return JSON.stringify({ deps: depsInfo });
        };

        // Root package: deps should only include DIRECT dependencies from Move.toml
        // not all transitive dependencies
        const directDeps = rootManifestDeps || [];

        // Root package first
        lines.push(`[pinned.${environment}.${rootPackageName}]`);
        lines.push("source = { root = true }");
        lines.push(`use_environment = "${environment}"`);
        const rootDigest = digestFn ? digestFn(buildDigestInputFromManifest(rootManifestDepsInfo, directDeps)) : "";
        lines.push(`manifest_digest = "${rootDigest}"`);
        if (directDeps.length > 0) {
            const depParts = directDeps.sort().map((name) => `${name} = "${name}"`);
            lines.push(`deps = { ${depParts.join(", ")} }`);
        } else {
            lines.push("deps = {}");
        }
        lines.push("");

        // Then each dependency
        for (const dep of deps) {
            const pkgName = dep.name;
            const sectionKey = `pinned.${environment}.${pkgName}`;

            lines.push(`[${sectionKey}]`);

            // Determine source from the source field
            const source = dep.source;
            if (source?.type === "git" && source?.git && source?.rev) {
                lines.push(
                    `source = { git = "${escapeTomlString(source.git)}", subdir = "${escapeTomlString(source.subdir || "")}", rev = "${escapeTomlString(source.rev)}" }`
                );
            } else if (source?.type === "local" && source?.local) {
                lines.push(`source = { local = "${escapeTomlString(source.local)}" }`);
            } else {
                // Fallback for system packages or unknown sources
                lines.push("source = { root = true }");
            }

            // Dependencies from manifestDeps or manifest.dependencies
            const depNames = dep.manifestDeps || Object.keys(dep.manifest?.dependencies || {});

            // use_environment and manifest_digest (required by V4 schema)
            lines.push(`use_environment = "${environment}"`);
            const depDigest = digestFn ? digestFn(buildDigestInputFromManifest(dep.manifest?.dependencies as Record<string, any>, depNames)) : "";
            lines.push(`manifest_digest = "${depDigest}"`);

            if (depNames.length > 0) {
                const depParts = depNames.sort().map((name) => `${name} = "${name}"`);
                lines.push(`deps = { ${depParts.join(", ")} }`);
            } else {
                lines.push("deps = {}");
            }

            lines.push("");
        }
    } catch {
        // If parsing fails, return minimal valid lockfile
        lines.push(`[pinned.${environment}.${rootPackageName}]`);
        lines.push("source = { root = true }");
        lines.push(`use_environment = "${environment}"`);
        lines.push(`manifest_digest = ""`);
        lines.push("deps = {}");
        lines.push("");
    }

    return lines.join("\n");
}
