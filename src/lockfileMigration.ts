import { parseToml } from "./tomlParser.js";

/**
 * Migrates a legacy Move.lock (v3 or older) to Published.toml content.
 *
 * ORIGINAL SOURCE REFERENCE: compatibility/legacy_lockfile.rs
 *
 * Logic (load_legacy_lockfile, line 23-77):
 * 1. Check version <= 3 (line 49-51)
 * 2. Parse [env.<network>] sections (line 85-123)
 * 3. Extract: chain-id, original-published-id, latest-published-id, published-version
 * 4. All 4 fields MUST be present for migration (line 108-109)
 *
 * Output Format (ParsedPublishedFile, from test line 195-211):
 * ```toml
 * [published.<network>]
 * chain-id = "<chain_id>"
 * published-at = "<64-char normalized address>"
 * original-id = "<64-char normalized address>"
 * version = <number>
 * ```
 *
 * @param legacyLockContent The content of the legacy Move.lock file.
 * @param targetNetwork Optional target network to migrate (if null, migrate all).
 * @param targetChainId Optional chain ID for fallback lookup.
 * @returns The content of the new Published.toml file, or null if no migration needed/possible.
 */
export function migrateLegacyLockToPublishedToml(
  legacyLockContent: string,
  _targetNetwork?: string,
  _targetChainId?: string
): string | null {
  try {
    const lock = parseToml(legacyLockContent);

    // ORIGINAL: line 49-51 - version > 3 means modern, skip
    const version = lock.move?.version ?? 0;
    if (version > 3) {
      return null;
    }

    // ORIGINAL: line 85-87 - get [env] section
    const envSection = lock.env;
    // DEBUG: Log env section
    // console.log(`[Migration Debug] envSection:`, JSON.stringify(envSection, null, 2));
    if (!envSection || typeof envSection !== "object") {
      return null;
    }

    // Collect all valid publications
    // ORIGINAL: line 89-123 - iterate over all environments
    const publications: Array<{
      network: string;
      chainId: string;
      originalId: string;
      publishedAt: string;
      version: number;
    }> = [];

    for (const [envName, envData] of Object.entries(envSection)) {
      if (!envData || typeof envData !== "object") continue;

      const env = envData as Record<string, unknown>;

      // ORIGINAL: line 93-106 - extract all 4 required fields
      const chainId = env["chain-id"] as string | undefined;
      const originalId = env["original-published-id"] as string | undefined;
      const latestId = env["latest-published-id"] as string | undefined;
      const publishedVersionStr = env["published-version"] as
        | string
        | undefined;

      // ORIGINAL: line 108-109 - ALL 4 fields must be present
      if (!chainId || !originalId || !latestId || !publishedVersionStr) {
        continue;
      }

      // ORIGINAL: line 106 - parse version as u64
      const publishedVersion = parseInt(publishedVersionStr, 10);
      if (isNaN(publishedVersion)) {
        continue;
      }

      // ORIGINAL: CLI migrates ALL environments from [env] section
      // See legacy_lockfile.rs:89-123 - no filtering by target network
      // The Published.toml should contain all publication info for all environments

      publications.push({
        network: envName,
        chainId,
        originalId: normalizeAddress(originalId),
        publishedAt: normalizeAddress(latestId),
        version: publishedVersion,
      });
    }

    if (publications.length === 0) {
      return null;
    }

    // ORIGINAL: CLI uses BTreeMap which sorts keys alphabetically
    // See legacy_lockfile.rs:73 - BTreeMap<EnvironmentName, LegacyEnvironment>
    publications.sort((a, b) => a.network.localeCompare(b.network));

    // Build Published.toml content
    // ORIGINAL: RenderToml for ParsedPublishedFile (test line 195-211)
    const lines = [
      `# Generated by Move`,
      `# This file contains metadata about published versions of this package in different environments`,
      `# This file SHOULD be committed to source control`,
      ``,
    ];

    for (const pub of publications) {
      lines.push(`[published.${pub.network}]`);
      lines.push(`chain-id = "${pub.chainId}"`);
      lines.push(`published-at = "${pub.publishedAt}"`);
      lines.push(`original-id = "${pub.originalId}"`);
      lines.push(`version = ${pub.version}`);
      lines.push(``);
    }

    return lines.join("\n");
  } catch (e) {
    console.warn("Failed to migrate legacy lockfile:", e);
    return null;
  }
}

/**
 * Normalize address to 0x-prefixed 64-char lowercase hex
 *
 * ORIGINAL SOURCE REFERENCE: move-core-types/src/account_address.rs
 *
 * Input handling (from_hex_literal, line 110-128):
 * - Accepts "0x" prefixed hex strings (e.g., "0x1", "0x2")
 * - Short addresses are LEFT-PADDED with zeros to 64 chars
 *
 * Output format (to_canonical_string, line 67-69):
 * - Always "0x" + 64 lowercase hex chars
 */
function normalizeAddress(addr: string): string {
  if (!addr) return addr;
  let clean = addr.trim();
  if (clean.startsWith("0x")) clean = clean.slice(2);

  // Only process valid hex strings
  if (!/^[0-9a-fA-F]+$/.test(clean)) {
    return addr;
  }

  // Left-pad with zeros and add 0x prefix (matches to_canonical_string)
  return "0x" + clean.toLowerCase().padStart(64, "0");
}
