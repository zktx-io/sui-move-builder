import { parseToml } from "./tomlParser.js";

/**
 * Migrates a legacy Move.lock (v3 or older) to Published.toml content.
 *
 * ORIGINAL SOURCE REFERENCE: compatibility/legacy_lockfile.rs
 *
 * Logic (load_legacy_lockfile, line 23-77):
 * 1. Check version <= 3 (line 49-51)
 * 2. Parse [env.<network>] sections (line 85-123)
 * 3. Extract: chain-id, original-published-id, latest-published-id, published-version
 * 4. All 4 fields MUST be present for migration (line 108-109)
 *
 * Output Format (ParsedPublishedFile, from test line 195-211):
 * ```toml
 * [published.<network>]
 * chain-id = "<chain_id>"
 * published-at = "<64-char normalized address>"
 * original-id = "<64-char normalized address>"
 * version = <number>
 * ```
 *
 * @param legacyLockContent The content of the legacy Move.lock file.
 * @param targetNetwork Optional target network to migrate (if null, migrate all).
 * @param targetChainId Optional chain ID for fallback lookup.
 * @returns The content of the new Published.toml file, or null if no migration needed/possible.
 */
export function migrateLegacyLockToPublishedToml(
  legacyLockContent: string,
  _targetNetwork?: string,
  _targetChainId?: string
): string | null {
  try {
    const lock = parseToml(legacyLockContent);

    // ORIGINAL: line 49-51 - version > 3 means modern, skip
    const version = lock.move?.version ?? 0;
    if (version > 3) {
      return null;
    }

    // ORIGINAL: line 85-87 - get [env] section
    const envSection = lock.env;
    // DEBUG: Log env section
    // console.log(`[Migration Debug] envSection:`, JSON.stringify(envSection, null, 2));
    if (!envSection || typeof envSection !== "object") {
      return null;
    }

    // Collect all valid publications
    // ORIGINAL: line 89-123 - iterate over all environments
    const publications: Array<{
      network: string;
      chainId: string;
      originalId: string;
      publishedAt: string;
      version: number;
    }> = [];

    for (const [envName, envData] of Object.entries(envSection)) {
      if (!envData || typeof envData !== "object") continue;

      const env = envData as Record<string, unknown>;

      // ORIGINAL: line 93-106 - extract all 4 required fields
      const chainId = env["chain-id"] as string | undefined;
      const originalId = env["original-published-id"] as string | undefined;
      const latestId = env["latest-published-id"] as string | undefined;
      const publishedVersionStr = env["published-version"] as
        | string
        | undefined;

      // ORIGINAL: line 108-109 - ALL 4 fields must be present
      if (!chainId || !originalId || !latestId || !publishedVersionStr) {
        continue;
      }

      // ORIGINAL: line 106 - parse version as u64
      const publishedVersion = parseInt(publishedVersionStr, 10);
      if (isNaN(publishedVersion)) {
        continue;
      }

      // ORIGINAL: CLI migrates ALL environments from [env] section
      // See legacy_lockfile.rs:89-123 - no filtering by target network
      // The Published.toml should contain all publication info for all environments

      publications.push({
        network: envName,
        chainId,
        originalId: normalizeAddress(originalId),
        publishedAt: normalizeAddress(latestId),
        version: publishedVersion,
      });
    }

    if (publications.length === 0) {
      return null;
    }

    // ORIGINAL: CLI uses BTreeMap which sorts keys alphabetically
    // See legacy_lockfile.rs:73 - BTreeMap<EnvironmentName, LegacyEnvironment>
    publications.sort((a, b) => a.network.localeCompare(b.network));

    // Build Published.toml content
    // ORIGINAL: RenderToml for ParsedPublishedFile (test line 195-211)
    const lines = [
      `# Generated by Move`,
      `# This file contains metadata about published versions of this package in different environments`,
      `# This file SHOULD be committed to source control`,
      ``,
    ];

    for (const pub of publications) {
      lines.push(`[published.${pub.network}]`);
      lines.push(`chain-id = "${pub.chainId}"`);
      lines.push(`published-at = "${pub.publishedAt}"`);
      lines.push(`original-id = "${pub.originalId}"`);
      lines.push(`version = ${pub.version}`);
      lines.push(``);
    }

    return lines.join("\n");
  } catch (e) {
    console.warn("Failed to migrate legacy lockfile:", e);
    return null;
  }
}

/**
 * Normalize address to 0x-prefixed 64-char lowercase hex
 *
 * ORIGINAL SOURCE REFERENCE: move-core-types/src/account_address.rs
 *
 * Input handling (from_hex_literal, line 110-128):
 * - Accepts "0x" prefixed hex strings (e.g., "0x1", "0x2")
 * - Short addresses are LEFT-PADDED with zeros to 64 chars
 *
 * Output format (to_canonical_string, line 67-69):
 * - Always "0x" + 64 lowercase hex chars
 */
function normalizeAddress(addr: string): string {
  if (!addr) return addr;
  let clean = addr.trim();
  if (clean.startsWith("0x")) clean = clean.slice(2);

  // Only process valid hex strings
  if (!/^[0-9a-fA-F]+$/.test(clean)) {
    return addr;
  }

  // Left-pad with zeros and add 0x prefix (matches to_canonical_string)
  return "0x" + clean.toLowerCase().padStart(64, "0");
}

/**
 * Strips [env] sections from V3 lockfile and converts to V4 format.
 *
 * ORIGINAL SOURCE REFERENCE: root_package.rs:269-276
 * When migrating, CLI creates a new lockfile with just [move] and [pinned] sections,
 * dropping all [env] sections that contained publish info.
 *
 * V3 Format:
 * [move]
 * version = 3
 * [env.mainnet]
 * chain-id = "..."
 * original-published-id = "..."
 * ...
 * [dependencies]
 * ...
 *
 * V4 Format:
 * [move]
 * version = 4
 * [pinned.mainnet.PackageName]
 * ...
 *
 * @param legacyLockContent The V3 Move.lock content
 * @returns The V4 Move.lock content with [env] sections removed, or null if not V3
 */
export function stripEnvSectionsFromV3Lockfile(
  legacyLockContent: string
): string | null {
  try {
    const lock = parseToml(legacyLockContent);

    // Only process V3 or older lockfiles
    const version = lock.move?.version ?? 0;
    if (version > 3) {
      return null;
    }

    // Check if there are [env] sections to strip
    if (!lock.env || typeof lock.env !== "object") {
      return null;
    }

    // Build V4 lockfile by removing [env] sections and updating version
    const lines: string[] = [];

    // [move] section with version 4
    lines.push("[move]");
    lines.push("version = 4");
    lines.push("");

    // Copy [dependencies] section if exists (preserves dependency resolution)
    if (lock.dependencies && typeof lock.dependencies === "object") {
      lines.push("[dependencies]");
      for (const [name, info] of Object.entries(lock.dependencies)) {
        if (typeof info === "object" && info !== null) {
          const depInfo = info as Record<string, string>;
          const parts: string[] = [];
          if (depInfo.name) parts.push(`name = "${depInfo.name}"`);
          if (depInfo.source) parts.push(`source = "${depInfo.source}"`);
          lines.push(`${name} = { ${parts.join(", ")} }`);
        }
      }
      lines.push("");
    }

    // Note: [pinned] sections will be generated by lockfileGenerator.ts after build
    // This function only strips [env] and updates version for pre-build migration

    return lines.join("\n");
  } catch (e) {
    console.warn("Failed to strip env sections from V3 lockfile:", e);
    return null;
  }
}

/**
 * Converts V3 lockfile with [[move.package]] array to V4 [pinned.*] format.
 *
 * ORIGINAL SOURCE REFERENCE:
 * - move-package-alt/src/compatibility/legacy_parser.rs
 * - move-package-alt/src/graph/to_lockfile.rs
 *
 * V3 Format (using [[move.package]] array):
 * ```toml
 * [move]
 * version = 3
 * manifest_digest = "..."
 * deps_digest = "..."
 * dependencies = [ { id = "Sui", name = "Sui" }, ... ]
 *
 * [[move.package]]
 * id = "MoveStdlib"
 * source = { git = "...", rev = "...", subdir = "..." }
 *
 * [[move.package]]
 * id = "Sui"
 * source = { git = "...", rev = "...", subdir = "..." }
 * dependencies = [ { id = "MoveStdlib", name = "MoveStdlib" } ]
 * ```
 *
 * V4 Format (using [pinned.{env}.{name}] sections):
 * ```toml
 * [move]
 * version = 4
 *
 * [pinned.mainnet.MoveStdlib]
 * source = { git = "...", rev = "...", subdir = "..." }
 * manifest_digest = "..."
 * deps = {}
 *
 * [pinned.mainnet.Sui]
 * source = { git = "...", rev = "...", subdir = "..." }
 * manifest_digest = "..."
 * deps = { MoveStdlib = "MoveStdlib" }
 * ```
 *
 * @param v3LockContent The V3 Move.lock content
 * @param environment Target environment name (e.g., "mainnet")
 * @returns The V4 Move.lock content, or null if not V3 or no packages
 */
export function convertV3MovePackageToV4Pinned(
  v3LockContent: string,
  environment: string = "mainnet"
): string | null {
  try {
    const lock = parseToml(v3LockContent);

    // Only process V3 or older lockfiles
    const version = lock.move?.version ?? 0;
    if (version > 3) {
      return null;
    }

    // Get [[move.package]] array
    const packages = lock.move?.package as
      | Array<{
          id: string;
          source?: {
            git?: string;
            rev?: string;
            subdir?: string;
            local?: string;
          };
          dependencies?: Array<{ id: string; name: string }>;
        }>
      | undefined;

    if (!packages || !Array.isArray(packages) || packages.length === 0) {
      return null;
    }

    // Get manifest_digest from [move] section if available
    const manifestDigest = lock.move?.manifest_digest as string | undefined;

    // Build V4 lockfile
    const lines: string[] = [];

    // [move] section with version 4
    lines.push("[move]");
    lines.push("version = 4");
    lines.push("");

    // Convert each [[move.package]] to [pinned.{env}.{name}]
    for (const pkg of packages) {
      if (!pkg.id) continue;

      lines.push(`[pinned.${environment}.${pkg.id}]`);

      // Source
      if (pkg.source) {
        if (pkg.source.git) {
          const parts: string[] = [];
          parts.push(`git = "${pkg.source.git}"`);
          if (pkg.source.subdir) parts.push(`subdir = "${pkg.source.subdir}"`);
          if (pkg.source.rev) parts.push(`rev = "${pkg.source.rev}"`);
          lines.push(`source = { ${parts.join(", ")} }`);
        } else if (pkg.source.local) {
          lines.push(`source = { local = "${pkg.source.local}" }`);
        }
      }

      // Use environment
      lines.push(`use_environment = "${environment}"`);

      // Manifest digest (use from [move] section if available, or generate placeholder)
      if (manifestDigest) {
        lines.push(`manifest_digest = "${manifestDigest}"`);
      }

      // Dependencies - convert from array to object
      if (pkg.dependencies && pkg.dependencies.length > 0) {
        const deps: string[] = [];
        for (const dep of pkg.dependencies) {
          deps.push(`${dep.name} = "${dep.id}"`);
        }
        lines.push(`deps = { ${deps.join(", ")} }`);
      } else {
        lines.push("deps = {}");
      }

      lines.push("");
    }

    return lines.join("\n");
  } catch (e) {
    console.warn("Failed to convert V3 Move.lock to V4:", e);
    return null;
  }
}
